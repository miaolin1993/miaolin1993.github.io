<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/a38a043ccecc258a.css" crossorigin="" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-35caa361a4f0814c.js" crossorigin=""/><script src="/_next/static/chunks/cfeffc86-0be39a03b00aa45e.js" async="" crossorigin=""></script><script src="/_next/static/chunks/452-996e614a19b63580.js" async="" crossorigin=""></script><script src="/_next/static/chunks/main-app-0fbf95a24b3a7107.js" async="" crossorigin=""></script><script src="/_next/static/chunks/827-f2365f9a8ea21fbf.js" async=""></script><script src="/_next/static/chunks/61-2d3c2f4a488ebf71.js" async=""></script><script src="/_next/static/chunks/864-fa6cdcbafc75ea43.js" async=""></script><script src="/_next/static/chunks/app/docs/layout-614096e2be5e85f5.js" async=""></script><script src="/_next/static/chunks/app/layout-434825532d849886.js" async=""></script><title>妙林的博客</title><meta name="description" content="Generated by create next app"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" crossorigin="" noModule=""></script></head><body class="__className_d65c78 min-h-screen bg-white dark:bg-dark-bg text-gray-900 dark:text-dark-text-primary antialiased transition-colors duration-200"><script>((e,t,r,n,o,l,u,a)=>{let i=document.documentElement,s=["light","dark"];function c(t){(Array.isArray(e)?e:[e]).forEach(e=>{let r="class"===e,n=r&&l?o.map(e=>l[e]||e):o;r?(i.classList.remove(...n),i.classList.add(l&&l[t]?l[t]:t)):i.setAttribute(e,t)}),a&&s.includes(t)&&(i.style.colorScheme=t)}if(n)c(n);else try{let e=localStorage.getItem(t)||r,n=u&&"system"===e?window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light":e;c(n)}catch(e){}})("class","theme","system",null,["light","dark"],null,true,true)</script><div class="min-h-screen bg-white dark:bg-dark-bg antialiased"><div class="mx-auto max-w-7xl"><div class="flex"><button class="lg:hidden fixed bottom-4 right-4 z-50 bg-blue-600 text-white p-3 rounded-full shadow-lg hover:bg-blue-700 transition-colors" aria-label="Toggle sidebar"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg></button><aside class="lg:hidden fixed top-[var(--navbar-height)] left-0 w-64 h-[calc(100vh-var(--navbar-height))] bg-white dark:bg-dark-bg z-50 transform transition-transform duration-200 ease-in-out -translate-x-full"><div class="h-full overflow-y-auto border-r border-slate-100 dark:border-dark-border"><nav class="py-4"><div class="space-y-1"></div></nav></div></aside><aside class="hidden lg:block w-64 shrink-0 h-[calc(100vh-var(--navbar-height))] sticky top-[var(--navbar-height)] bg-slate-50/50 dark:bg-dark-bg-secondary/50"><div class="h-full overflow-y-auto border-r border-slate-100 dark:border-dark-border"><nav class="py-4"><div class="space-y-1"></div></nav></div></aside><main class="flex-1 min-w-0"><div class="py-12 px-10 lg:px-12 max-w-4xl mx-auto"><div class="prose prose-slate dark:prose-invert max-w-none"><div class="container mx-auto px-4 py-8 sm:py-12"><div class="max-w-3xl mx-auto"><h1 class="text-2xl sm:text-4xl font-bold mb-4 text-gray-900 dark:text-gray-100">服务端渲染</h1><div class="prose prose-slate dark:prose-invert max-w-none prose-sm sm:prose-base lg:prose-lg"><h2 id="与客户端渲染区别">与客户端渲染区别</h2>
<ol>
<li>渲染时机不同</li>
</ol>
<ul>
<li>
<p>服务端渲染简称SSR，是将各种资源在后端处理完成后，返回完整的html给前端，直接渲染</p>
</li>
<li>
<p>客户端渲染简称CSR，html页面是空壳子，内容需要通过浏览器在前端来渲染，并通过脚本方式插入html中</p>
</li>
</ul>
<ol start="2">
<li>加载速度区别大</li>
</ol>
<ul>
<li>服务端渲染因为是提前渲染好了页面，所以加载速度是非常快的</li>
<li>客户端渲染因为要在前端执行渲染，就会出现加载慢、性能差等问题</li>
</ul>
<ol start="3">
<li>网页内容获取不同</li>
</ol>
<ul>
<li>服务端因为提前都处理好了，一些SEO内容，或是有需要抓取页面数据等诉求，可以直接获取到</li>
<li>客户端渲染则因为脚本生成的原因，导致无法SEO，而且无法抓取页面内容</li>
</ul>
<h2 id="优势与不足">优势与不足</h2>
<p>基于上面说的区别，可以看出服务端渲染的优势：</p>
<ul>
<li>提升首屏加载速度</li>
<li>SEO优化</li>
<li>共享链接时显示预览（因为内容都在html上面所以可以显示预览）</li>
</ul>
<p>当然服务端渲染也不是万能的，也会有一些不足的地方：</p>
<ul>
<li>开发复杂度增加</li>
<li>服务器压力增大（通过缓存）</li>
<li>状态管理复杂，前端和后端都需要维护状态</li>
</ul>
<p>同时呢，有些内容是必须在客户端渲染的，比如：</p>
<ul>
<li>canvas</li>
<li>事件绑定</li>
<li>层叠样式表的解析</li>
</ul>
<p>这样又会增加一些难度，于是又有了很多综合性的方案，比如前后端同构，混合渲染等</p>
<h2 id="原理和表现形式">原理和表现形式</h2>
<p>最早接触服务端渲染，那会还没有做前端，Python有个Django框架，这个框架就是基于服务端渲染的，那个时候用的还是模板引擎替换的方式，替换模板标签，而现代的服务端渲染跟过去的模板标签替换略有些不同</p>
<p><strong>模板引擎替换</strong></p>
<p>过去的模板标签形式简单说就是预准备一段html，静态的部分直接写出来，动态可变的部分用<code>{{ }}或{% %}</code>等标签标记，内部写上可变的变量，等到执行渲染时，将这些打标记的地方替换成变量对应的值，从而完成整个页面的渲染</p>
<p><strong>现代服务端渲染</strong></p>
<p>现代的服务端渲染，不只是简单的模板替换了，现代的项目基于React/vue等工程化项目，要保留通过服务端渲染内容提高性能，同时还要保留现有的工程化能力</p>
<p>相当于要在返回html之前，也就是在打包构建阶段，就对整个工程化项目完成处理，之后在将打包好的内容插入到html并返回</p>
<h2 id="注水和脱水">注水和脱水</h2>
<p>注水（Hydration）是指客户端将服务器返回的静态HTML与JavaScript结合，使其成为可交互的动态页面。脱水（Dehydration）则是服务器在渲染时将应用的状态序列化，嵌入到HTML中，供客户端注水时使用。</p>
<p>脱水（Dehydration）：</p>
<p>指在服务端渲染过程中，将组件的状态（State）或数据（Data）序列化（Serialize），嵌入到生成的 HTML 中，传递给客户端，供客户端注水时使用</p>
<h3 id="简版流程">简版流程</h3>
<ul>
<li>服务端脱水：</li>
</ul>
<p>渲染组件 → 获取数据 → 序列化状态 → 嵌入 HTML。</p>
<ul>
<li>客户端注水：</li>
</ul>
<p>加载 HTML → 解析初始状态 → 初始化应用 → 激活交互。</p>
<h3 id="作用">作用</h3>
<ul>
<li>避免客户端重复请求数据。</li>
<li>确保服务端和客户端初始状态一致。</li>
</ul>
<h3 id="实现">实现</h3>
<ul>
<li>服务端渲染组件时，会执行数据获取逻辑（如 API 请求），生成最终状态。</li>
<li>将这些状态序列化为字符串（如 JSON），通过 script 标签注入到 HTML 中</li>
</ul>
<p>react为例，官方提供的方法</p>
<ul>
<li>服务端：renderToString</li>
<li>客户端：hydrateRoot</li>
</ul>
<h2 id="从0开始设计一个极简ssr项目">从0开始设计一个极简SSR项目</h2>
<p><a href="https://github.com/miaolin1993/interview-question/tree/master/%E6%9E%81%E7%AE%80%E7%89%88%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93," title="项目地址">极简项目地址</a></p>
<p>这里展示部分代码</p>
<p>服务端渲染组件, 依赖renderToString方法，脱水处理</p>
<pre><code>import React from &#x27;react&#x27;
import { renderToString } from &#x27;react-dom/server&#x27;
import Test from &#x27;./test.jsx&#x27;

export function render() {
    return renderToString(&lt;Test /&gt;)
}
</code></pre>
<p>客户端注水，依赖hydrateRoot</p>
<pre><code>import React from &#x27;react&#x27;
import { hydrateRoot } from &#x27;react-dom/client&#x27;
import Test from &#x27;./test.jsx&#x27;

hydrateRoot(document.getElementById(&#x27;app&#x27;), &lt;Test /&gt;)
</code></pre>
<p>html模板</p>
<pre><code>&lt;body&gt;
  测试服务端渲染
  &lt;div id=&quot;app&quot;&gt;
    &lt;!-- 替换react代码 --&gt;
  &lt;/div&gt;
  &lt;script type=&quot;module&quot; src=&quot;/main.jsx&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>最终渲染融合挂载</p>
<pre><code>app.use(&#x27;*&#x27;, async (req, res) =&gt; {
    // 使用vite进行模板渲染
    const template = await vite.transformIndexHtml(req.url, fs.readFileSync(&#x27;index.html&#x27;, &#x27;utf-8&#x27;))
    // 用vite进行组件渲染
    const { render } = await vite.ssrLoadModule(&quot;render.jsx&quot;)
    // 将react组件挂载到模板
    const reactHtml = render()
    const html = template.replace(&#x27;&lt;!-- 替换react代码 --&gt;&#x27;, reactHtml)
    // 渲染并返回最终模板
    res.send(html)
})
</code></pre>
<p>这样就实现了前面说的在返回html前完成react的打包渲染，并嵌入到html，从而完成了一个最基本的服务端渲染过程</p></div></div></div></div></div></main><aside class="hidden xl:block w-64 shrink-0"><nav class="sticky top-[calc(var(--navbar-height)+2.5rem)] border-l border-[#ebedf1] dark:border-dark-border pl-4 text-[13px] text-slate-700 dark:text-dark-text-secondary py-4"></nav></aside></div></div></div><script src="/_next/static/chunks/webpack-35caa361a4f0814c.js" crossorigin="" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/a38a043ccecc258a.css\",\"style\",{\"crossOrigin\":\"\"}]\n0:\"$L2\"\n"])</script><script>self.__next_f.push([1,"3:I[2832,[],\"\"]\n6:I[1381,[],\"\"]\n8:I[5735,[],\"\"]\n9:I[9221,[\"827\",\"static/chunks/827-f2365f9a8ea21fbf.js\",\"61\",\"static/chunks/61-2d3c2f4a488ebf71.js\",\"864\",\"static/chunks/864-fa6cdcbafc75ea43.js\",\"998\",\"static/chunks/app/docs/layout-614096e2be5e85f5.js\"],\"\"]\na:I[6943,[\"185\",\"static/chunks/app/layout-434825532d849886.js\"],\"ThemeProvider\"]\nc:I[5532,[],\"\"]\n7:[\"slug\",\"tech/server\",\"oc\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"2:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/a38a043ccecc258a.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"Zw-iRkNXwX_fkeKNui5ok\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/docs/tech/server/\",\"initialTree\":[\"\",{\"children\":[\"docs\",{\"children\":[[\"slug\",\"tech/server\",\"oc\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"tech\\\",\\\"server\\\"]}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"docs\",{\"children\":[[\"slug\",\"tech/server\",\"oc\"],{\"children\":[\"__PAGE__\",{},[\"$L4\",\"$L5\",null]]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"docs\",\"children\",\"$7\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}]]},[null,[\"$\",\"$L9\",null,{\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"docs\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],\"params\":{}}],null]]},[null,[\"$\",\"html\",null,{\"lang\":\"en\",\"suppressHydrationWarning\":true,\"children\":[\"$\",\"body\",null,{\"className\":\"__className_d65c78 min-h-screen bg-white dark:bg-dark-bg text-gray-900 dark:text-dark-text-primary antialiased transition-colors duration-200\",\"children\":[\"$\",\"$La\",null,{\"attribute\":\"class\",\"defaultTheme\":\"system\",\"enableSystem\":true,\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"styles\":null}]}]}]}],null]],\"initialHead\":[false,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"妙林的博客\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"Generated by create next app\"}],[\"$\",\"link\",\"4\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n4:null\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"container mx-auto px-4 py-8 sm:py-12\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-3xl mx-auto\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-2xl sm:text-4xl font-bold mb-4 text-gray-900 dark:text-gray-100\",\"children\":\"服务端渲染\"}],null,[\"$\",\"div\",null,{\"className\":\"prose prose-slate dark:prose-invert max-w-none prose-sm sm:prose-base lg:prose-lg\",\"children\":\"$Le\"}]]}]}]\n"])</script><script>self.__next_f.push([1,"e:[[\"$\",\"h2\",null,{\"id\":\"与客户端渲染区别\",\"children\":\"与客户端渲染区别\"}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"渲染时机不同\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"服务端渲染简称SSR，是将各种资源在后端处理完成后，返回完整的html给前端，直接渲染\"}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"客户端渲染简称CSR，html页面是空壳子，内容需要通过浏览器在前端来渲染，并通过脚本方式插入html中\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"ol\",null,{\"start\":\"2\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"加载速度区别大\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"服务端渲染因为是提前渲染好了页面，所以加载速度是非常快的\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"客户端渲染因为要在前端执行渲染，就会出现加载慢、性能差等问题\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ol\",null,{\"start\":\"3\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"网页内容获取不同\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"服务端因为提前都处理好了，一些SEO内容，或是有需要抓取页面数据等诉求，可以直接获取到\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"客户端渲染则因为脚本生成的原因，导致无法SEO，而且无法抓取页面内容\"}],\"\\n\"]}],\"\\n\",[\"$\",\"h2\",null,{\"id\":\"优势与不足\",\"children\":\"优势与不足\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"基于上面说的区别，可以看出服务端渲染的优势：\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"提升首屏加载速度\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"SEO优化\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"共享链接时显示预览（因为内容都在html上面所以可以显示预览）\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"当然服务端渲染也不是万能的，也会有一些不足的地方：\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"开发复杂度增加\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"服务器压力增大（通过缓存）\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"状态管理复杂，前端和后端都需要维护状态\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"同时呢，有些内容是必须在客户端渲染的，比如：\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"canvas\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"事件绑定\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"层叠样式表的解析\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"这样又会增加一些难度，于是又有了很多综合性的方案，比如前后端同构，混合渲染等\"}],\"\\n\",[\"$\",\"h2\",null,{\"id\":\"原理和表现形式\",\"children\":\"原理和表现形式\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"最早接触服务端渲染，那会还没有做前端，Python有个Django框架，这个框架就是基于服务端渲染的，那个时候用的还是模板引擎替换的方式，替换模板标签，而现代的服务端渲染跟过去的模板标签替换略有些不同\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"strong\",null,{\"children\":\"模板引擎替换\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"过去的模板标签形式简单说就是预准备一段html，静态的部分直接写出来，动态可变的部分用\",[\"$\",\"code\",null,{\"children\":\"{{ }}或{% %}\"}],\"等标签标记，内部写上可变的变量，等到执行渲染时，将这些打标记的地方替换成变量对应的值，从而完成整个页面的渲染\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"strong\",null,{\"children\":\"现代服务端渲染\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"现代的服务端渲染，不只是简单的模板替换了，现代的项目基于React/vue等工程化项目，要保留通过服务端渲染内容提高性能，同时还要保留现有的工程化能力\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"相当于要在返回html之前，也就是在打包构建阶段，就对整个工程化项目完成处理，之后在将打包好的内容插入到html并返回\"}],\"\\n\",[\"$\",\"h2\",null,{\"id\":\"注水和脱水\",\"children\":\"注水和脱水\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"注水（Hydration）是指客户端将服务器返回的静态HTML与JavaScript结合，使其成为可交互的动态页面。脱水（Dehydration）则是服务器在渲染时将应用的状态序列化，嵌入到HTML中，供客户端注水时使用。\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"脱水（Dehydration）：\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"指在服务端渲染过程中，将组件的状态（State）或数据（Data）序列化（Serialize），嵌入到生成的 HTML 中，传递给客户端，供客户端注水时使用\"}],\"\\n\",[\"$\",\"h3\",null,{\"id\":\"简版流程\",\"children\":\"简版流程\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"服务端脱水：\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"渲染组件 → 获取数据 → 序列化状态 → 嵌入 HTML。\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"客户端注水：\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"加载 HTML → 解析初始状态 → 初始化应用 → 激活交互。\"}],\"\\n\",[\"$\",\"h3\",null,{\"id\":\"作用\",\"children\":\"作用\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"避免客户端重复请求数据。\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"确保服务端和客户端初始状态一致。\"}],\"\\n\"]}],\"\\n\",[\"$\",\"h3\",null,{\"id\":\"实现\",\"children\":\"实现\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"服务端渲染组件时，会执行数据获取逻辑（如 API 请求），生成最终状态。\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"将这些状态序列化为字符串（如 JSON），通过 script 标签注入到 HTML 中\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"react为例，官方提供的方法\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"服务端：renderToString\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"客户端：hydrateRoot\"}],\"\\n\"]}],\"\\n\",[\"$\",\"h2\",null,{\"id\":\"从0开始设计一个极简ssr项目\",\"children\":\"从0开始设计一个极简SSR项目\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"https://github.com/miaolin1993/interview-question/tree/master/%E6%9E%81%E7%AE%80%E7%89%88%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93,\",\"title\":\"项目地址\",\"children\":\"极简项目地址\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"这里展示部分代码\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"服务端渲染组件, 依赖renderToString方法，脱水处理\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"import React from 'react'\\r\\nimport { renderToString } from 'react-dom/server'\\r\\nimport Test from './test.jsx'\\r\\n\\r\\nexport function render() {\\r\\n    return renderToString(\u003cTest /\u003e)\\r\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"客户端注水，依赖hydrateRoot\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"import React from 'react'\\r\\nimport { hydrateRoot } from 'react-dom/client'\\r\\nimport Test from './test.jsx'\\r\\n\\r\\nhydrateRoot(document.getElementById('app'), \u003cTest /\u003e)\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"html模板\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"\u003cbody\u003e\\r\\n  测试服务端渲染\\r\\n  \u003cdiv id=\\\"app\\\"\u003e\\r\\n    \u003c!-- 替换react代码 --\u003e\\r\\n  \u003c/div\u003e\\r\\n  \u003cscript type=\\\"module\\\" src=\\\"/main.jsx\\\"\u003e\u003c/script\u003e\\r\\n\u003c/body\u003e\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"最终渲染融合挂载\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"app.use('*', async (req, res) =\u003e {\\r\\n    // 使用vite进行模板渲染\\r\\n    const template = await vite.transformIndexHtml(req.url, fs.readFileSync('index.html', 'utf-8'))\\r\\n    // 用vite进行组件渲染\\r\\n    const { render } = await vite.ssrLoadModule(\\\"render.jsx\\\")\\r\\n    // 将react组件挂载到模板\\r\\n    const reactHtml = render()\\r\\n    const html = template.replace('\u003c!-- 替换react代码 --\u003e', reactHtml)\\r\\n    // 渲染并返回最终模板\\r\\n    res.send(html)\\r\\n})\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"这样就实现了前面说的在返回html前完成react的打包渲染，并嵌入到html，从而完成了一个最基本的服务端渲染过程\"}]]\n"])</script><script>self.__next_f.push([1,""])</script></body></html>